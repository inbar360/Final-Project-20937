from clients import Client
from utils import decodes_utf8, ReqState, RequestCodes, decrypt_file_using_aes_key
from utils import create_aes_key, create_uuid, create_directory, get_client_file_path, remove_client_file
from cksum import readfile
from Crypto.PublicKey import RSA


def handle_one_param(server, client_id: bytes, code: RequestCodes, unpacked_payload) -> ReqState:
    """
    Process unpacked request payload with a single payload argument and invoke the corresponding methods.

    :param server: The server that communicates with the clients.
    :param client_id: The client's id.
    :param code: The request code, one of (825, 827, 900, 901, 902).
    :param unpacked_payload: A tuple object containing all request payload arguments.

    :return: The response code generated by the server.
    """

    print("code =", code)

    name_in_bytes = unpacked_payload[0]
    name: str = decodes_utf8(name_in_bytes)

    match code:
        case RequestCodes.REGISTRATION:
            return register(server, name)
        case RequestCodes.RECONNECTION:
            return reconnect(server, client_id, name)
        case _:
            return crc_requests(server, client_id, code, file_name=name)


def handle_sending_public_key(server, client_id: bytes, code: RequestCodes, unpacked_payload: tuple) -> ReqState:
    """
    Process Sending Public Key request (826).

    :param server: The server that communicates with the clients.
    :param client_id: The client's id.
    :param code: The request code.
    :param unpacked_payload: A tuple object containing all request payload arguments.

    :return: The response code generated by the server.
    """
    print("got to handle sending public key!")

    name_in_bytes, public_key = unpacked_payload
    name = decodes_utf8(name_in_bytes)

    print("name =", name, "and id =", client_id)
    # If the client name and id don't match in the dictionary, return general error.
    if not server.client_registered(client_id, name):
        return ReqState.GENERAL_ERROR

    # Create the AES key, save both public and AES keys into the dictionary, and return public key received state.
    aes_key: bytes = create_aes_key()
    pub_key_as_rsa = RSA.import_key(public_key)

    print(f"non-encrypted AES key = {aes_key}")

    server.get_client(client_id).set_public_key(pub_key_as_rsa)
    server.get_client(client_id).set_aes_key(aes_key)
    return ReqState.PUBLIC_KEY_RECEIVED


def handle_sending_file(server, client_id: bytes, code: RequestCodes, unpacked_payload: tuple) -> ReqState:
    """
    Process Sending File request (828).
    # ASSUMPTIONS: * The packets are being sent in the correct order.
                   * The server replies only after the last packet has been received.
                   * Each client only sends one file.

    :param server: The server that communicates with the clients.
    :param client_id: The client's id.
    :param code: The request code.
    :param unpacked_payload: A tuple object containing all request payload arguments.

    :return: The response code generated by the server.
    """
    print("got to handle sending file!")

    content_size, orig_size, pack_num, tot_packets, file_name_bytes, content = unpacked_payload
    client: Client = server.get_client(client_id)
    file_name = decodes_utf8(file_name_bytes)

    # If it's the first instance of request 828 - save file name and total packets.
    if client.get_file_name() is None:
        client.set_file_name(file_name)
        client.set_tot_packets(tot_packets)

    # Add the current packet's data. If all packets were received, decrypt, calc CRC and return response code 1603.
    client.add_packet_data(pack_num, content)
    if client.received_entire_file():
        decrypt_file_calc_crc(client, client_id)
        return ReqState.FILE_RECEIVED_CRC

    # If not all packets were received, return response code indicating no response.
    return ReqState.AWAIT_PACKET


def decrypt_file_calc_crc(client: Client, client_id: bytes) -> None:
    """
    Decrypt the client's file and calculate CRC.

    :param client: The client object.
    :param client_id: The client id corresponding to the provided client object.
    """
    # Create directory for the file and write all packets' data into it.
    str_id: str = decodes_utf8(client_id)
    create_directory(str_id)
    client_file_path: str = get_client_file_path(str_id, client.get_file_name())
    with open(client_file_path, 'wb') as client_file:
        for packet_data in client.get_packets().values():
            client_file.write(packet_data.strip(b'\0'))

    # Get the decrypted file data and write it back to the file in binary format.
    decrypted_data = decrypt_file_using_aes_key(client_file_path, client.get_aes_key())
    client.set_content_size(len(decrypted_data))

    with open(client_file_path, 'wb') as client_file:
        client_file.write(decrypted_data)

    # Calculate CRC and save it.
    crc = readfile(client.get_file_name())
    client.set_crc(crc)

    print(f"CRC = {crc}")


def register(server, name: str) -> ReqState:
    """
    Process Register request (825).

    :param server: The server that communicates with the clients.
    :param name: The name of the client requesting registration.

    :return: The response code generated by the server.
    """
    print("got to handle register!")

    if server.name_already_registered(name):
        return ReqState.CLIENT_NAME_REGISTERED

    # Create the uuid, check if it exists, if not add to the dictionary and return true.
    uuid = create_uuid()
    while server.client_id_registered(uuid):
        uuid = create_uuid()

    # Add the client to the dictionary of clientss and return succussful registration state.
    server.add_client(name, uuid)
    print(f"UUID = {uuid}")

    return ReqState.REGISTERED_SUCCESSFULLY


# This method handles the request of reconnection of a client.
# In the assignment I saw response 1606 returns a UUID, so if the client cannot reconnect, the server tries to register
# the client right away, instead of waiting for the client to send a registration request.
def reconnect(server, client_id: bytes, name: str) -> ReqState:
    """
    Process Reconnection request (827).
    # ASSUMPTIONS: * If the client cannot reconnect, the server tries registration instead.

    :param server: The server that communicates with the clients.
    :param client_id: The id of the client requesting reconnection.
    :param name: The name of the client requesting reconnection.

    :return: The response code generated by the server.
    """
    print("got to handle reconnect!")

    if not server.client_registered(client_id, name) or (server.get_client(client_id).get_public_key() is None):
        server.remove_client_if_registered(client_id, name)
        reg = register(server, name)

        # If the client is not registered but can register, return that the client needs to register.
        if reg == ReqState.REGISTERED_SUCCESSFULLY:
            print(f"register instead of reconnect, UUID = {server.get_uuid_by_name(name)}")
            return ReqState.NOT_REGISTERED_OR_INVALID_KEY
        return ReqState.GENERAL_ERROR

    # If the client is registered, create AES key, save it, and return successful reconnection state.
    aes_key = create_aes_key()
    server.get_client(client_id).set_aes_key(aes_key)

    print(f"non-encrypted AES key = {aes_key}")

    return ReqState.RECONNECTED_SUCCESSFULLY


def crc_requests(server, client_id: bytes, code: RequestCodes, file_name: str) -> ReqState:
    """
    Process CRC related requests (900-902).

    :param server: The server that communicates with the clients.
    :param client_id: The client's id.
    :param code: The request code.
    :param file_name: The file name provided by the client.

    :return: The response code generated by the server.
    """
    print("got to handle CRC requests!")
    # If the id isn't registered, the client had not sent a file yet, the client is in the process of sending a file,
    # or the given name and the client's file name are differnet, return general error.
    if (not server.client_id_registered(client_id)) or \
       (not server.get_client(client_id).received_entire_file()) or \
       (server.get_client(client_id).get_file_name() != file_name):
        return ReqState.GENERAL_ERROR

    # delete user file if the crc was incorrect.
    if code == RequestCodes.INVALID_CRC_SENDING_AGAIN or code == RequestCodes.FOURTH_TIME_INVALID_CRC:
        str_id = decodes_utf8(client_id)
        client = server.get_client(client_id)
        path = get_client_file_path(str_id, client.get_file_name())
        remove_client_file(path)

    # If the request is 901 - 'Invalid CRC, sending again', no response is needed.
    if code == RequestCodes.INVALID_CRC_SENDING_AGAIN:
        server.get_client(client_id).clear_dict()  # Clear the packet dictionary.
        return ReqState.AWAIT_FILE

    # Valid request codes 900/902, returning response code 1604.
    return ReqState.MESSAGE_RECEIVED


# A dictionay used in order to call the handle request by parameters amount functions.
requests_functions = {
    825: handle_one_param,
    826: handle_sending_public_key,
    827: handle_one_param,
    828: handle_sending_file,
    900: handle_one_param,
    901: handle_one_param,
    902: handle_one_param
}
